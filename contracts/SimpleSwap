// SPDX-License-Identifier: MIT
// Compatible with OpenZeppelin Contracts ^5.0.0
pragma solidity ^0.8.27;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/// @title Interface for SimpleSwap
interface ISimpleSwap {
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB);

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function getPrice(address tokenA, address tokenB) external view returns (uint256 price);
    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external view returns (uint256);
}



contract SimpleSwap is ISimpleSwap, ERC20 {


     /*///////////////////////////////////////////////////////////////
                           TYPES
      //////////////////////////////////////////////////////////////*/

    enum SwapDirection {
        A_to_B, B_to_A
    }

     /*///////////////////////////////////////////////////////////////
                           STATE
      //////////////////////////////////////////////////////////////*/

    // we should have used private variables instantiated in the constructor for the two tokens,
    // rather than overcomplicating the swap interface by adding the token addresses in every function call
    // IERC20 public _tokenA;
    // IERC20 public _tokenB;

     /*///////////////////////////////////////////////////////////////
                           EVENTS
      //////////////////////////////////////////////////////////////*/
    /**
     * @notice someone added liquidity to the pool
     * @param lProvider:  address of liquidity provider
     * @param amountAIn: amount of token A deposited
     * @param amountBIn: amount of token B deposited
     * @param liquidityTokensOut: amount of LP shares minted
     */
    event LiquidityAdded(address indexed lProvider, uint amountAIn, uint amountBIn, uint liquidityTokensOut); 

    /**
     * @notice some LP removed liquidity to the pool
     * @param lProvider:  address of liquidity provider
     * @param liquidityTokensIn: amount of LP shares burnt
     * @param amountAOut: amount of token A received/withdrawn
     * @param amountBOut: amount of token B received/withdrawn
     */
    event LiquidityRemoved(address indexed lProvider, uint liquidityTokensIn, uint amountAOut, uint amountBOut); 
    
     /**
     * @notice a swap has been performed, 
     * either from A to B, in which case amountBIn == amountAOut == 0,
     * or from B to A, in which case amountAIn == amountBOut == 0
     * @param sender:  address of provider of input tokens
     * @param receiver: address of recipient of output tokens
     * @param amountAIn: amount of token A deposited
     * @param amountBIn: amount of token B deposited
     * @param amountAOut: amount of token A received/withdrawn
     * @param amountBOut: amount of token B received/withdrawn
     */
    event Swap(
        address indexed sender, 
        address indexed receiver, 
        uint amountAIn, 
        uint amountBIn,     
        uint amountAOut, 
        uint amountBOut
    ); 

     /*///////////////////////////////////////////////////////////////
                           ERRORS
      //////////////////////////////////////////////////////////////*/

     /**
      * @notice invalid token address for interaction
      */
    error INVALID_TOKEN();

     /**
      * @notice invalid address to send tokens to (address(0))
      */
    error INVALID_TO();

     /**
      * @notice insufficient amount of expected output tokens, 
      * below minimum desired
      */
    error INSUFFICIENT_OUTPUT_AMOUNT();

    /**
      * @notice proposed liquidity provision would unbalance pool, 
      * breaking the invariant x * y == k
      */
    error UNBALANCED_LIQUIDITY_PROVISION();

    /**
      * @notice deadline expired to perform operation
      */
    error DEADLINE_EXPIRED();

    /**
      * @notice invalid swap route
      * in our simple set up, it should have length 2
      * and consists of either [tokenA,tokenB] or [tokenB,tokenA]
      */
    error INVALID_SWAP_ROUTE();

     /*///////////////////////////////////////////////////////////////
                           MODFIFIERS
      //////////////////////////////////////////////////////////////*/

    /**
      * @notice must be performed up to deadline
      */
    modifier onlyBeforeDeadline (uint deadline){
        if (block.timestamp > deadeline) {
            revert DEADLINE_EXPIRED();
        }
        _;
    }

    /**
      * @notice must not use address(0)
      */
    modifier onlyValidAddress (address to){
        if (to == address(0)) {
            revert INVALID_TO();
        }
        _;
    }

    /*///////////////////////////////////////////////////////////////
                           HELPER FUNCTIONS
      //////////////////////////////////////////////////////////////*/

    /**
     * @dev Calculates the optimal amount of tokenA and tokenB to add to the liquidity pool
     * based on desired amounts and current pool reserves.
     * @param amountADesired The maximum amount of tokenA the caller is willing to deposit.
     * @param amountBDesired The maximum amount of tokenB the caller is willing to deposit.
     * @param reserveA The current reserve of tokenA in the pair contract.
     * @param reserveB The current reserve of tokenB in the pair contract.
     * @return amounts The calculated actual amounts of tokenA and tokenB to be deposited.
     */
    function _calculateAmountsToDeposit(
        uint amountADesired,
        uint amountBDesired,
        uint reserveA,
        uint reserveB
    ) internal pure returns (uint amountA, uint amountB) {
   //     uint reserveA = tokenA.balanceOf(address(this));
   //     uint reserveB = tokenB.balanceOf(address(this));
        if (reserveA == 0 && reserveB == 0) {
            // First liquidity provision for this pair.
            // In this simplified example, we'll just use the desired amounts directly.
            // A real Uniswap Router would likely ensure both are non-zero.
            return (amountADesired, amountBDesired);
        }

        // Calculate amountB needed if we use all of amountADesired at current ratio
        uint amountBOptimal = (amountADesired * reserveB) / reserveA;

        if (amountBOptimal <= amountBDesired) {
            // We have enough B to match desired A
            amountA = amountADesired;
            amountB = amountBOptimal;
        } else {
            // We don't have enough B, so use all of desired B and calculate A
            uint amountAOptimal = (amountBDesired * reserveA) / reserveB;
            amountA = amountAOptimal;
            amountB = amountBDesired;
        }
    }

    /**
     * @dev Calculates the amount of liquidity tokens to mint,
     * based on deposited amounts and current pool reserves.
     * Special case: initial liquidity provision, no reserves.
     * @param amountADeposited amount of tokens A deposited.
     * @param amountBDeposited amount of tokens B deposited.
     * @param reserveA The current reserve of tokenA in the swap contract.
     * @param reserveB The current reserve of tokenB in the swap contract.
     * @param totalLP the total supply of LP_AB tokens minted so far.
     * @return liquidtyTokens The amount of LP_AB tokens to mint.
     */
    function _calculateLiquidityToMint(
        uint amountADeposited,
        uint amountBDeposited,
        uint reserveA,
        uint reserveB,
        uint totalLP
    ) internal pure returns (uint liquidityTokens){
        // gas saving: we read totalSupply() state variable into a local one
         // uint totalLP = totalSupply();
        // check whether this is the inital liquidity provision
        if ( reserveA == 0 && reserveB == 0){
            liquidityTokens = sqrt(amountADeposited * amountBDeposited);
        } else {
            liquidityTokens = min((amountADeposited * totalLP)/reserveA, (amountBDeposited * totalLP)/reserveB)
        }
    }

    /**
     * @dev Calculates the amount of tokens to withdraw when redeeming liquidity,
     * based on current pool reserves.
     * @param liquidityToBurn amount of liquidity tokens to redeem.
     * @param reserveA The current reserve of tokenA in the swap contract.
     * @param reserveB The current reserve of tokenB in the swap contract.
     * @param totalLP the total supply of LP_AB tokens minted so far.
     * @return amounts of A and B tokens to withdraw from the pool.
     */
    function _calculateExitLiquidity(
        uint liquidityToBurn,
        uint reserveA,
        uint reserveB,
        uint totalLP
    ) internal pure returns (uint amountAOut, uint amountBOut){
        // we could check totalLP != 0, but let Solidity safe math take care of it
        amountAOut = (liquidityToBurn * reserveA) / totalLP;
        amountBOut = (liquidityToBurn * reserveB) / totalLP;
    }

    /*///////////////////////////////////////////////////////////////
                          CONSTRUCTOR
      //////////////////////////////////////////////////////////////*/
    constructor(address tokenA_, address tokenB_) ERC20("LPShares_AB","LP_AB"){
        _tokenA = IERC20(tokenA_);
        _tokenB = IERC20(tokenB_)
    }


    /*///////////////////////////////////////////////////////////////
                           LOGIC
      //////////////////////////////////////////////////////////////*/

     /**
     * @dev Adds liquidity to the pool.
     * @param tokenA The address of the first token.
     * @param tokenB The address of the second token.
     * @param amountADesired The maximum amount of tokenA to deposit.
     * @param amountBDesired The maximum amount of tokenB to deposit.
     * @param amountAMin The minimum amount of tokenA to accept. Transaction reverts if less is used.
     * @param amountBMin The minimum amount of tokenB to accept. Transaction reverts if less is used.
     * @param to The address to receive the liquidity tokens.
     * @param deadline The unix timestamp after which the transaction will revert.
     * @return amountA The actual amount of tokenA deposited.
     * @return amountB The actual amount of tokenB deposited.
     * @return liquidity The amount of liquidity tokens minted.
     */
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity) onlyBeforeDeadline(deadline) onlyValidAddress(to) {
        // 1. gas saving: we read the reserves into local variables, as they are used in various calculations
        uint reserveA = IERC20(tokenA).balanceOf(address(this));
        uint reserveB = IERC20(tokenB).balanceOf(address(this));
        uint totalLP = totalSupply();

        // 2. compute the optimal amounts to deposit
        (uint amountA, uint amountB) =  _calculateAmountsToDeposit(
                                             amountADesired,
                                             amountBDesired,
                                             reserveA,
                                             reserveB
                                        );

        // 3. check whether required minimums are met 
        if (amountA < amountAMin || amountB < amountBMin){
            revert UNBALANCED_LIQUIDITY_PROVISION();
        }

        //4. transfer tokens from sender into swap contract
        IERC20(tokenA).transferFrom(msg.sender, address(this), amountA);
        IERC20(tokenB).transferFrom(msg.sender, address(this), amountB);

        //5. calculate amount of liquidity tokens to mint
        (uint liquidityTokens =  _calculateLiquidityToMint(
                                    amountA,
                                    amountB,
                                    reserveA,
                                    reserveB,
                                    totalLP
                                );
        //6. if we got a positive quantity, 
        // mint the corresponding tokens to the target address using the internal _mint
        // and emit the corresponding event
        if (liquidityTokens > 0){
            _mint(liquidityTokens,msg.sender);
            emit LiquidityAdded(msg.sender, amountA, amountB, liquidityTokens); 
        }
}
